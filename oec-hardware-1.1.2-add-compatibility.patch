From 1d0d56a7a62da272a42cd1bbd4222c6cb1431ba9 Mon Sep 17 00:00:00 2001
From: meitingli <limeiting1@huawei.com>
Date: Sat, 3 Sep 2022 11:21:11 +0800
Subject: [PATCH] Add generate compatibility information and bugfix

---
 hwcompatible/cert_info.py | 101 ++++++++++++++++++++++++++++++++++++++
 hwcompatible/constants.py |   2 +-
 hwcompatible/device.py    |   2 +
 hwcompatible/job.py       |  11 ++++-
 tests/cpufreq/cpufreq.py  |   8 +--
 tests/gpu/gpu.py          |   6 +--
 6 files changed, 120 insertions(+), 10 deletions(-)
 create mode 100644 hwcompatible/cert_info.py

diff --git a/hwcompatible/cert_info.py b/hwcompatible/cert_info.py
new file mode 100644
index 0000000..741e49a
--- /dev/null
+++ b/hwcompatible/cert_info.py
@@ -0,0 +1,101 @@
+#!/usr/bin/env python3
+# coding: utf-8
+# oec-hardware is licensed under the Mulan PSL v2.gica's
+# You can use this software according to the terms and conditions of the Mulan PSL v2.
+# You may obtain a copy of Mulan PSL v2 at:
+#     http://license.coscl.org.cn/MulanPSL2
+# THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR
+# IMPLIED, INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY OR FIT FOR A PARTICULAR
+# PURPOSE.
+# See the Mulan PSL v2 for more details.
+# Author: @meitingli
+# Create: 2022-08-24
+# Desc: Generate compatibility json file
+
+import os
+import json
+from datetime import date
+from .env import CertEnv
+from .constants import FILE_FLAGS, FILE_MODES
+
+
+class CertInfo:
+    def __init__(self, logger, command):
+        self.cert_devices = []
+        self.cert_quads = []
+        self.infos = ["vendorID", "deviceID", "svID", "ssID", "architecture", "os", "driverName", "version",
+                      "type", "date", "sha256", "driverSize", "chipVendor", "boardModel", "chipModel", "downloadLink"]
+        self.logger = logger
+        self.command = command
+
+    def create_json(self, device):
+        """
+        Create hardware information json
+        Args:
+            device: hardware device
+        Returns: True/False
+        """
+        if not device or not device.quad:
+            self.logger.warning(
+                "The %s doesn't have quadruple information, couldn't get hardware." % device.name)
+            return False
+
+        if device.quad in self.cert_quads:
+            return True
+
+        oec_json = {}
+        for info in self.infos:
+            oec_json[info] = ""
+
+        self.logger.info(
+            "Please input sha256, driverSize, downloadLink for %s manually "
+            "if you use outbox driver." % device.name)
+
+        oec_json["vendorID"] = device.quad[0]
+        oec_json["deviceID"] = device.quad[1]
+        oec_json["svID"] = device.quad[2]
+        oec_json["ssID"] = device.quad[3]
+        oec_json["driverName"] = device.driver
+        oec_json["version"] = device.driver_version
+        chip_vendor = self.command.run_cmd(
+            "grep '^%s' %s | cut -d ' ' -f 3" % (device.quad[0], CertEnv.pcifile), log_print=False)
+        oec_json["chipVendor"] = chip_vendor[0].strip("\n")
+        oec_json["boardModel"] = device.board
+        oec_json["chipModel"] = device.chip
+        oec_json["type"] = device.name
+        arch = self.command.run_cmd("uname -m", log_print=False)
+        oec_json["architecture"] = arch[0].strip("\n")
+        os_cmd = self.command.run_cmd(
+            "grep openeulerversion /etc/openEuler-latest | cut -d '=' -f 2", log_print=False)
+        os_version = os_cmd[0].strip("\n").replace('-', ' ')
+        oec_json["os"] = os_version
+        curday = date.today().strftime("%Y.%m.%d")
+        oec_json["date"] = curday
+        shanum = self.command.run_cmd(
+            "modinfo %s | grep signature | awk '{print $2}'" % device.driver, log_print=False)
+        oec_json["sha256"] = shanum[0].replace(":", "").strip("\n")
+        filename = self.command.run_cmd(
+            "modinfo %s | grep filename | awk '{print $2}'" % device.driver, log_print=False)
+        driver_size = self.command.run_cmd(
+            "ls -lh %s | awk '{print $5}'" % filename[0], log_print=False)
+        oec_json["driverSize"] = driver_size[0].strip("\n")
+        oec_json["downloadLink"] = "inbox"
+
+        self.cert_quads.append(device.quad)
+        self.cert_devices.append(oec_json)
+        return True
+
+    def export_cert_info(self):
+        """
+        Export device cert informations to json file
+        """
+        if not self.cert_devices:
+            self.logger.info("There is no cert device need to export.")
+            return
+
+        name = "hw_compatibility.json"
+        file = os.path.join(self.logger.logdir, name)
+        with os.fdopen(os.open(file, FILE_FLAGS, FILE_MODES), "w", encoding='utf-8') as fd_cert:
+            fd_cert.write(json.dumps(self.cert_devices, indent=4))
+
+        self.logger.info("The cert device json file is created succeed.")
diff --git a/hwcompatible/constants.py b/hwcompatible/constants.py
index bd7e038..86713d8 100644
--- a/hwcompatible/constants.py
+++ b/hwcompatible/constants.py
@@ -33,7 +33,7 @@ KEYCARD_VENDORS = ('Xilinx', 'Renesas', 'Texas', 'PLX')
 IB = "infiniband"
 DEVICE_INFO = ('color', 'status', 'num', 'run', 'name',
                'device', 'driver', 'version', 'chip', 'board')
-NO_CONFIG_DEVICES = ("gpu", "vgpu", "nvme", "dpdk", "cdrom")
+NO_CONFIG_DEVICES = ("gpu", "vgpu", "nvme", "dpdk", "cdrom", "keycard")
 
 # File access control
 FILE_FLAGS = os.O_WRONLY | os.O_CREAT | os.O_TRUNC
diff --git a/hwcompatible/device.py b/hwcompatible/device.py
index 72e57fa..1bd6218 100755
--- a/hwcompatible/device.py
+++ b/hwcompatible/device.py
@@ -69,6 +69,7 @@ class Device:
     def __init__(self, properties=None, logger=None):
         self.logger = logger
         self.command = Command(self.logger)
+        self.name = ""
         self.path = ""
         self.pci = ""
         self.quad = list()
@@ -109,6 +110,7 @@ class Device:
         get board model name
         :return:
         """
+        self.name = name
         self.file = file
         self.file.seek(0)
         # get PCI number
diff --git a/hwcompatible/job.py b/hwcompatible/job.py
index fe04a14..0005eb6 100755
--- a/hwcompatible/job.py
+++ b/hwcompatible/job.py
@@ -22,7 +22,8 @@ from .env import CertEnv
 from .command import Command
 from .log import Logger
 from .reboot import Reboot
-from .constants import NO_CONFIG_DEVICES
+from .cert_info import CertInfo
+from .constants import NO_CONFIG_DEVICES, NODEVICE
 
 
 class Job():
@@ -59,7 +60,7 @@ class Job():
         for tests in self.test_suite:
             for pkg in tests["test"].requirements:
                 cmd_result = self.command.run_cmd(
-                    "rpm -q %s" % pkg, ignore_errors=True)
+                    "rpm -q %s" % pkg, ignore_errors=True, log_print=False)
                 return_code = cmd_result[2]
                 if return_code != 0 and pkg not in required_rpms:
                     required_rpms.append(pkg)
@@ -88,17 +89,23 @@ class Job():
 
         self.get_config()
         self.test_suite.sort(key=lambda k: k["test"].pri)
+        cert_infos = CertInfo(self.logger, self.command)
         for testcase in self.test_suite:
             config_data = self.get_device(testcase)
             if self._run_test(testcase, config_data, subtests_filter):
                 testcase["status"] = "PASS"
                 self.logger.info("Test %s succeed." %
                                  testcase["name"], terminal_print=False)
+
+                if testcase["name"] not in NODEVICE:
+                    cert_infos.create_json(testcase["device"])
             else:
                 testcase["status"] = "FAIL"
                 self.logger.error("Test %s failed." %
                                   testcase["name"], terminal_print=False)
 
+        cert_infos.export_cert_info()
+
     def run(self):
         """
         Test entrance
diff --git a/tests/cpufreq/cpufreq.py b/tests/cpufreq/cpufreq.py
index d01d9d9..98e7305 100644
--- a/tests/cpufreq/cpufreq.py
+++ b/tests/cpufreq/cpufreq.py
@@ -262,7 +262,7 @@ class CPUFreqTest(Test):
             return False
         self.logger.info("Set governor of all CPUs to ondemand succeed.")
 
-        target_cpu = randint(0, self.cpu.nums)
+        target_cpu = randint(0, self.cpu.nums-1)
         target_cpu_governor = self.cpu.get_governor(target_cpu)
         if target_cpu_governor != 'ondemand':
             self.logger.error("The governor of CPU%s(%s) is not ondemand." % (
@@ -311,7 +311,7 @@ class CPUFreqTest(Test):
             return False
         self.logger.info("Set governor of all CPUs to conservative.")
 
-        target_cpu = randint(0, self.cpu.nums)
+        target_cpu = randint(0, self.cpu.nums-1)
         target_cpu_governor = self.cpu.get_governor(target_cpu)
         if target_cpu_governor != 'conservative':
             self.logger.error("The governor of CPU%s(%s) is not conservative." %
@@ -350,7 +350,7 @@ class CPUFreqTest(Test):
             return False
         self.logger.info("Set governor of all CPUs to powersave.")
 
-        target_cpu = randint(0, self.cpu.nums)
+        target_cpu = randint(0, self.cpu.nums-1)
         target_cpu_governor = self.cpu.get_governor(target_cpu)
         if target_cpu_governor != 'powersave':
             self.logger.error("The governor of CPU%s(%s) is not powersave." %
@@ -389,7 +389,7 @@ class CPUFreqTest(Test):
             return False
         self.logger.info("Set governor of all CPUs to performance.")
 
-        target_cpu = randint(0, self.cpu.nums)
+        target_cpu = randint(0, self.cpu.nums-1)
         target_cpu_governor = self.cpu.get_governor(target_cpu)
         if target_cpu_governor != 'performance':
             self.logger.error("The governor of CPU%s(%s) is not performance." %
diff --git a/tests/gpu/gpu.py b/tests/gpu/gpu.py
index 665bbdf..7260b99 100644
--- a/tests/gpu/gpu.py
+++ b/tests/gpu/gpu.py
@@ -78,8 +78,8 @@ class GpuTest(Test):
             os.environ['CUDA_VISIBLE_DEVICES'] = id_num
 
         self.command.run_cmd("bash %s/test_gpu.sh install_gpu_burn" % gpu_dir)
-        self.command.run_cmd(
-            '/opt/gpu-burn/gpu_burn 10 | tee %s' % self.gpu_burn)
+        os.chdir("/opt/gpu-burn")
+        self.command.run_cmd('./gpu_burn 10 | tee %s' % self.gpu_burn)
         time.sleep(1)
         for _ in range(10):
             cmd = self.command.run_cmd(
@@ -116,4 +116,4 @@ class GpuTest(Test):
         except Exception as e:
             self.logger.error(
                 "Failed to run the script because compiling or setting variables: %s" % e)
-            return False
+            return False
\ No newline at end of file
-- 
2.33.0

